<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
	<meta name="color-scheme" content="dark light">
	<title>Dataviz App</title>
	<style>
	</style>
</head>

<body>
	<h1 class="display-1 mt-4"></h1>

    <script src="js/helpers.js"></script>
    <script src="js/sankey-functions.js"></script>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.1.0/dist/d3-scale-chromatic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js" crossorigin="anonymous"></script>

	<div id="app">

        <div class="grid-controls"
             style="font-family: thesansosfplain, Helvetica, Arial, sans-serif; margin: auto; width: 50%;
                grid-row-start: 1; grid-row-end: 1; grid-column-start: 1; grid-column-end: 3;">
            <div class="controls d-flex p-2"
                 style="width: 80%; font-family: thesansosfplain, Helvetica, Arial, sans-serif;
                  margin: auto auto 0.2rem;display: flex; align-items: center; @media (max-width: 385px) {display: grid;}">
                <div>
                    <button class="btn btn-outline-dark p-3" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="fa-solid fa-ellipsis-vertical fa-xl"></i>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-dark">
                        <li><a id="download-as-png-link" class="dropdown-item" href="#download-as-png-link" onclick="saveToPng()">Exporter en tant que PNG</a></li>
                        <li><a id="download-as-jpeg-link" class="dropdown-item" href="#download-as-jpeg-link" onclick="saveToJpeg()">Exporter en tant que JPEG</a></li>
                        <li><a id="download-as-svg-link" class="dropdown-item" href="#download-as-svg-link" onclick="saveToSvg()">Exporter en tant que SVG</a></li>
                        <li><hr/></li>
                        <li>
                            <div class="cdc-controls-container dropdown-item"
                                 style="padding-right: 3rem; display: -ms-flexbox; display: -webkit-flex; display: flex; align-items: center;
                          align-self: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-align: center;">
                                <label for="yearSlider" style="display: block; padding-right: 0.5rem; padding-left: 0.2rem;">Volée</label>
                                <select id="yearSlider" onchange="updateYear(this.value)"></select>
                            </div>
                        </li>
                        <li>
                            <div class="cdc-controls-container dropdown-item" style="padding-right: 3rem; display: -ms-flexbox; display: -webkit-flex; display: flex; align-items: center;
                          align-self: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-align: center;">
                                <label for="widthSlider" style="display: block; padding-right: 0.5rem; padding-left: 0.2rem;">Largeur</label>
                                <input id="widthSlider" type="range" step="20" min="0" max="0" class="slider" oninput="updateWidth(this.value)">
                            </div>
                        </li>
                        <li>
                            <div class="cdc-controls-container dropdown-item" style="padding-right: 3rem; display: -ms-flexbox; display: -webkit-flex; display: flex; align-items: center;
                          align-self: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-align: center;">
                                <label for="heightSlider" style="display: block; padding-right: 0.5rem; padding-left: 0.2rem;">Hauteur</label>
                                <input id="heightSlider" type="range" step="20" min="0" max="0" class="slider" oninput="updateHeight(this.value)">
                            </div>
                        </li>
                        <li>
                            <div class="cdc-controls-container dropdown-item" style="padding-right: 3rem; display: -ms-flexbox; display: -webkit-flex; display: flex; align-items: center;
                          align-self: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-align: center;">
                                <label for="responsivenessCheckbox" style="display: block; padding-right: 0.5rem; padding-left: 0.2rem;">Responsive</label>
                                <input type="checkbox" id="responsivenessCheckbox" name="Checkbox for diagram responsiveness" onchange="handleResponsiveness(this.checked)">
                            </div>
                        </li>
                        <li>
                            <div class="cdc-controls-container dropdown-item" style="padding-right: 3rem; display: -ms-flexbox; display: -webkit-flex; display: flex; align-items: center;
                          align-self: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-align: center;">
                                <button id="id-btn-reset-chart-dimensions" type="button" class="btn btn-dark" onclick="resetChartDimensions()" style="display: none">Réinitialiser</button>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="grid-main-container" style="grid-row-start: 2; grid-row-end: 3; grid-column-start: 1; grid-column-end: 3;">
            <div>
                <div class="content-box" style="height: max-content; display: block; margin: 0 auto; width: 50%">
                    <div class="chart-container"
                         style="width: 700px; height: auto; @media screen and (max-width: 420px) {width: 90vw; height: auto;}
                      @media screen and (min-width: 981px) and (max-width: 1600px) {width: 770px; height: 88vh;}
                      @media screen and (min-width: 1600px) {width: 950px; height: 88vh;}">
                        <svg id="sankey-chart" style="margin: 0 auto; display: inline-block;"></svg>
                    </div>
                    <div id="tooltip" class="custom-tooltip"
                         style="position: absolute; text-align: justify; width: auto; max-width: 30em; height: auto; padding: 2px;
                      font-family: thesansosfplain, Helvetica, Arial, sans-serif; background: lightsteelblue; border: 0;
                      border-radius: 8px; pointer-events: none;">
                    </div>

                    <div>
                        <!-- Modal component -->
                        <div class="cdc-dataviz-modal-component-wrapper" style="position: fixed; z-index: 999; top: 20%; left: 50%; width: 70%; margin-left: -150px;">
                            <div id="id-cdc-dataviz-modal-wrapper" class="cdc-dataviz-modal-wrapper" style="display: none; height: 100vh; align-items: center; justify-content: center;">
                                <div id="id-cdc-dataviz-modal-mask" class="cdc-dataviz-modal-mask" style="position: fixed; z-index: 9998; top: 0; right: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: grid; transition: opacity 0.3s ease; overflow-y: auto;" tabindex="0">
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
	</div>

    <script>

        const { ref, shallowRef, nextTick, onMounted } = Vue;

        // Indicates when to display the popup
        // Indique quand faire apparaître le popup
        const open = ref(false);

        const playerVars = {
            autoplay: 0,
            mute: 0,
            controls: 1,
            cookie: false
        };

        let data = [];

        const sankeyChartId = "sankey-chart";
        const backgroundColor = "white";

        const jpegFormatType = "image/jpeg";
        const pngFormatType = "image/png";
        const svgFormatType = "image/svg+xml";


        /*
        Respondent data :
          - data" corresponds to detailed information on the respondents
          - years" corresponds to the years in which diplomas were obtained
          - selectedYear" allows the user to select a specific year. By default, all years are taken into account
         */
        /*
        Données relatives aux répondants :
          - "data" correspond aux données détaillées sur les répondants
          - "years" correspond aux années d'obtention des diplômes
          - "selectedYear" permet à l'utilisateur de choisir une volée spécifique. Par défaut, toutes sont prises en compte
         */
        let years = ["Toutes", 2013, 2015, 2017];       // A modifier manuellement
        let selectedYear = ref("Toutes");

        /*
        Sankey diagram parameters :
          - NODE_WIDTH" corresponds to the width of the nodes
          - NODE_PADDING" corresponds to the vertical separation distance between nodes
          (See https://github.com/d3/d3-sankey for more information)
         */
        /*
        Paramètres relatifs au diagramme de Sankey :
          - "NODE_WIDTH" correspond à la largeur des nœuds
          - "NODE_PADDING" correspond à la distance de séparation verticale entre les nœuds
          (Voir https://github.com/d3/d3-sankey pour plus d'informations)
         */
        const NODE_WIDTH = 60;
        const NODE_PADDING = 20;

        /*
        Variables useful for the application :
          - chartData" corresponds to the data required to create the diagram (labels, nodes, links)
          - SCALING_FACTOR" increases diagram dimensions
          - DEFAULT_LEFT_TITLE" corresponds to the default left-hand title
          - DEFAULT_RIGHT_TITLE" corresponds to the default right-hand title
          - lastFac" corresponds to the last faculty with which the user interacted
          - lastProspect" corresponds to the last outlet with which the user interacted
          - currentChartState" tracks the current state of the diagram (4 possible states)
          - leftDeepDown" indicates whether a deep down has been performed from faculties to diplomas
          - rightDeepDown" indicates whether a deep down has been performed from broad prospects to specific prospects
          - dimensionsUpdated" indicates whether diagram dimensions have been modified by the user
          - checkboxForResponsiveness" allows the user to make the diagram responsive or not
         */
        /*
        Variables utiles au bon fonctionnement de l'application :
          - "chartData" correspond aux données nécessaires à la création du diagramme (labels, nœuds, liens)
          - "SCALING_FACTOR" permet d'augmenter les dimensions du diagramme
          - "DEFAULT_LEFT_TITLE" correspond au titre de gauche par défaut
          - "DEFAULT_RIGHT_TITLE" correspond au titre de droite par défaut
          - "lastFac" correspond à la dernière faculté avec laquelle l'utilisateur a interagi
          - "lastProspect" correspond au dernier débouché avec lequel l'utilisateur a interagi
          - "currentChartState" permet de faire un suivi de l'état actuel du diagramme (4 états possibles)
          - "leftDeepDown" indique si un deep down a été effectué des facultés vers les diplômes
          - "rightDeepDown" indique si un deep down a été effectué des débouchés larges vers les débouchés spécifiques
          - "dimensionsUpdated" indique si les dimensions du diagramme ont été modifiées par l'utilisateur
          - "checkboxForResponsiveness" permet à l'utilisateur de rendre le diagramme "responsive" ou non
         */
        let chartData;
        const SCALING_FACTOR = 1.4;

        const DEFAULT_LEFT_TITLE = "Faculté";
        const DEFAULT_RIGHT_TITLE = "Débouché";

        let lastFac = "";
        let lastProspect = "";

        let currentChartState;

        let leftDeepDown = shallowRef(false);
        let rightDeepDown = shallowRef(false);

        let dimensionsUpdated = shallowRef(false);

        let checkboxForResponsiveness = shallowRef(true);

        /*
        Variables specific to diagram dimensions :
          - margin" is used to customize the diagram's margins
          - computedWidth" corresponds to the initial width of the diagram
          - computedHeight" corresponds to the diagram's initial height
          - width" and "height" are refs (Vue.js reactive state)
         */
        /*
        Variables spécifiques aux dimensions du diagramme :
          - "margin" permet de personnaliser les marges du diagramme
          - "computedWidth" correspond à la largeur initiale du diagramme
          - "computedHeight" correspond à la hauteur initiale du diagramme
          - "width" et "height" sont des refs (état réactif de Vue.js)
         */
        const margin = { top: 100, right: 900, bottom: 50, left: 300 };

        const minWidth = 1100;
        const maxWidth = 2800;
        const minHeight = 500;
        const maxHeight = 2300;
        const defaultWidth = 1500;
        const defaultHeight = 600;

        const computedWidth = defaultWidth * 0.9;
        const computedHeight = defaultHeight * SCALING_FACTOR;

        const width = ref(computedWidth);
        const height = ref(computedHeight);

        const commentDotsSolidIconSvgPath =
            `M256 448c141.4 0 256-93.1 256-208S397.4 32 256 32S0 125.1 0 240c0 45.1 17.7 86.8 47.7 120.9c-1.9 24.5-11.4
    46.3-21.4 62.9c-5.5 9.2-11.1 16.6-15.2 21.6c-2.1 2.5-3.7 4.4-4.9 5.7c-.6 .6-1 1.1-1.3 1.4l-.3 .3 0 0 0 0 0
    0 0 0c-4.6 4.6-5.9 11.4-3.4 17.4c2.5 6 8.3 9.9 14.8 9.9c28.7 0 57.6-8.9 81.6-19.3c22.9-10 42.4-21.9 54.3-30.6c31.8
    11.5 67 17.9 104.1 17.9zM128 208a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm128 0a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm96
    32a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z`;

        // Populate year dropdown
        // On remplit la liste déroulante des années
        const yearSlider = document.getElementById('yearSlider');
        years.forEach((year) => {
            const option = document.createElement('option');
            option.value = year;
            option.text = year;
            yearSlider.add(option);
        });

        // Set initial values for width and height sliders
        // On définit les valeurs initiales des curseurs de largeur et de hauteur
        document.getElementById('widthSlider').min = minWidth;
        document.getElementById('widthSlider').max = maxWidth;
        document.getElementById('widthSlider').value = width.value;

        document.getElementById('heightSlider').min = minHeight;
        document.getElementById('heightSlider').max = maxHeight;
        document.getElementById('heightSlider').value = height.value;

        // Fonction permettant de mettre à jour valeur de l'année sélectionnée
        // Function to update the value of the selected year
        function updateYear(newYear) {
            selectedYear.value = newYear;
            width.value = computedWidth;
            height.value = computedHeight;
            switch (currentChartState) {
                case CHART_STATES.ONE:
                    chartData = getData("", "", selectedYear.value);
                    updateChart(chartData, currentChartState, newYear, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, height.value);
                    break;
                case CHART_STATES.TWO:
                    chartData = getData(lastFac, "", selectedYear.value);
                    updateChart(chartData, currentChartState, newYear, lastFac, DEFAULT_RIGHT_TITLE, width.value, height.value);
                    break;
                case CHART_STATES.THREE:
                    chartData = getData("", lastProspect, selectedYear.value);
                    updateChart(chartData, currentChartState, newYear, DEFAULT_LEFT_TITLE, lastProspect, width.value, height.value);
                    break;
                case CHART_STATES.FOUR:
                    chartData = getData(lastFac, lastProspect, selectedYear.value);
                    updateChart(chartData, currentChartState, newYear, lastFac, lastProspect, width.value, height.value);
                    break;
                default:
                    break;
            }
        }

        // Fonction permettant de mettre à jour la largeur du diagramme
        // Function to update diagram width
        function updateWidth(newWidth) {
            width.value = newWidth;
            switch (currentChartState) {
                case CHART_STATES.ONE:
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, newWidth, height.value);
                    break;
                case CHART_STATES.TWO:
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, DEFAULT_RIGHT_TITLE, newWidth, height.value);
                    break;
                case CHART_STATES.THREE:
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, lastProspect, newWidth, height.value);
                    break;
                case CHART_STATES.FOUR:
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, lastProspect, newWidth, height.value);
                    break;
                default:
                    break;
            }

            if (checkboxForResponsiveness) {
                dimensionsUpdated.value = !(newWidth === computedWidth && height.value === computedHeight);
            }
            else {
                dimensionsUpdated.value = !(newWidth === (computedWidth * 0.9) && height.value === (computedHeight * 0.7));
            }
            const resetDimensionsButton = document.getElementById('id-btn-reset-chart-dimensions');
            resetDimensionsButton.style.display = dimensionsUpdated.value ? '' : 'none';
        }

        // Fonction permettant de mettre à jour la hauteur du diagramme
        // Function to update diagram height
        function updateHeight(newHeight) {
            height.value = newHeight;
            switch (currentChartState) {
                case CHART_STATES.ONE:
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, newHeight);
                    break;
                case CHART_STATES.TWO:
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, DEFAULT_RIGHT_TITLE, width.value, newHeight);
                    break;
                case CHART_STATES.THREE:
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, lastProspect, width.value, newHeight);
                    break;
                case CHART_STATES.FOUR:
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, lastProspect, width.value, newHeight);
                    break;
                default:
                    break;
            }

            if (checkboxForResponsiveness) {
                dimensionsUpdated.value = !(width.value === computedWidth && newHeight === computedHeight);
            }
            else {
                dimensionsUpdated.value = !(width.value === (computedWidth * 0.9) && newHeight === (computedHeight * 0.7));
            }
            const resetDimensionsButton = document.getElementById('id-btn-reset-chart-dimensions');
            resetDimensionsButton.style.display = dimensionsUpdated.value ? '' : 'none';
        }

        // Function to handle responsiveness
        // // Fonction permettant de gérer l'aspect responsive
        function handleResponsiveness(isResponsive) {
            checkboxForResponsiveness = isResponsive;
            if (checkboxForResponsiveness) {
                width.value = computedWidth;
                height.value = computedHeight;
                d3.select("#sankey-chart").attr("style", "max-width: 100%; height: auto;");
                d3.select(".content-box").attr("style", "height: max-content; display: block; margin: auto; width: 50%");
            }
            else {
                width.value = computedWidth * 0.9;
                height.value = computedHeight * 0.7;
                d3.select("#sankey-chart").attr("style", "height: auto;");
                d3.select(".content-box").attr("style", "height: max-content; display: block; margin: auto; width: 100%");
            }
        }

        /**
         * Permet de mettre à jour les informations du popup
         *
         * @property {Array} data                   - Le tableau de données
         * @property {String} item.job              - Poste actuel
         * @property {String} item.url              - Url du contenu multimédia
         * @property {String} item.degree           - Diplôme
         * @property {String} item.faculty          - Faculté
         * @property {String} item.last_name        - Nom
         * @property {String} item.first_name       - Prénom
         * @property {String} item.youtube_link     - Lien youtube
         * @property {Object} item.url_embed        - Lien embed du contenu multimédia
         * @property {String} item.url_embed.id     - Id du lien embed
         * @property {String} item.url_embed.src    - Source du lien embed
         * @returns {void}
         */
        function updateModalInfo() {
            // On supprime tous les éléments sous le "modal mask"
            const modalContainer = document.getElementById('id-cdc-dataviz-modal-mask');
            removeAllChildNodes(modalContainer);

            // Loop through the 'data' array and create modal wrappers
            data.forEach((item) => {
                // Create a new div element for the modal wrapper
                const modalWrapper = document.createElement('div');
                modalWrapper.classList.add('cdc-dataviz-modal-wrapper');
                modalWrapper.style.cssText = 'display: flex; height: 100vh; align-items: center; justify-content: center;'

                // Create a new div element for the modal container
                const modalContent = document.createElement('div');
                modalContent.classList.add('cdc-dataviz-modal-container');
                modalContent.style.cssText = 'width: 50%; height: 80%; display: flex; flex-direction: column; align-items: center;\n' +
                    '                        margin: 0 auto; padding: 10px 20px; background-color: #fff; border-radius: 20px;\n' +
                    '                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.33); transition: all 0.3s ease;\n' +
                    '                        font-family: thesansosfplain, Helvetica, Arial, sans-serif;'

                // Create the header section
                const header = document.createElement('div');
                header.classList.add('cdc-dataviz-modal-header', 'cdc-dataviz-modal-component-center');
                header.style.cssText = 'width: 100%; height: auto; display: flex; justify-content: center; align-items: center;'

                const card = document.createElement('div');
                card.classList.add('cdc-dataviz-card');
                card.style.cssText = 'width: 70%; border-radius: 0.75rem; background: #f2f2f2; display: flex; color: black;\n' +
                    '                              box-shadow:  0 22px 70px 4px rgba(0,0,0,0.56), 0 0 0 1px rgba(0, 0, 0, 0.3); align-items: center;\n' +
                    '                              justify-content: center; font-family: thesansosfplain, Helvetica, Arial, sans-serif;\n' +
                    '                              will-change: transform; &:hover { transform: scale(1.1);\n' +
                    '                              box-shadow:  0 32px 80px 14px rgba(0,0,0,0.36), 0 0 0 1px rgba(0, 0, 0, 0.3);}\n' +
                    '                              transition: transform 0.25s cubic-bezier(0.4, 0.0, 0.2, 1), box-shadow 0.25s cubic-bezier(0.4, 0.0, 0.2, 1);\n' +
                    '                              @media screen and (max-width: 280px) {width: 100%;} @media screen and (max-width: 400px) { width: 90vw;}\n' +
                    '                              @media screen and (min-width: 401px) and (max-width: 912px) {width: 100%;}\n' +
                    '                              @media screen and (max-width: 1024px) and (max-height: 600px) {width: 50vw;}'

                const cardDetails = document.createElement('div');
                cardDetails.classList.add('cdc-dataviz-card-details');
                cardDetails.style.cssText = 'padding: 1rem;'

                const nameElement = document.createElement('div');
                nameElement.classList.add('cdc-dataviz-card-details-name');
                nameElement.style.cssText = 'font-size: 1.25rem; @media screen and (max-width: 280px) {font-size: 0.9rem;}\n' +
                    '                                  @media screen and (max-width: 393px) {font-size: 1rem;}'
                nameElement.textContent = displayName(item);

                const occupationElement = document.createElement('div');
                occupationElement.classList.add('cdc-dataviz-card-details-occupation');
                occupationElement.style.cssText = 'font-weight: 600; @media screen and (max-width: 280px) { font-size: 0.75rem;}\n' +
                    '                                  @media screen and (max-width: 393px) {font-size: 0.8rem;}'
                occupationElement.textContent = item.job;

                const cardAbout = document.createElement('div');
                cardAbout.classList.add('cdc-dataviz-card-details-card-about');
                cardAbout.style.cssText = 'margin-top: 1rem; display: grid; column-gap: 2em; grid-auto-flow: column;\n' +
                    '                                  @media screen and (max-width: 600px) {display: inline;}'

                const facultyItem = document.createElement('div');
                facultyItem.classList.add('cdc-dataviz-card-details-card-about-item');
                facultyItem.style.cssText = 'display: flex; flex-direction: column; margin-bottom: 0.5rem;'

                const facultyLabel = document.createElement('span');
                facultyLabel.classList.add('cdc-dataviz-card-details-card-about-item-value');
                facultyLabel.style.cssText = 'font-size: 1rem;'
                facultyLabel.textContent = 'Faculté';

                const facultyValue = document.createElement('span');
                facultyValue.classList.add('cdc-dataviz-card-details-card-about-item-label');
                facultyValue.style.cssText = 'margin-top: 0.15rem; font-size: 0.75rem; font-weight: 600;'
                facultyValue.textContent = item.faculty;

                const degreeItem = document.createElement('div');
                degreeItem.classList.add('cdc-dataviz-card-details-card-about-item');
                degreeItem.style.cssText = 'display: flex; flex-direction: column; margin-bottom: 0.5rem;'

                const degreeLabel = document.createElement('span');
                degreeLabel.classList.add('cdc-dataviz-card-details-card-about-item-value');
                degreeLabel.style.cssText = 'font-size: 1rem;';
                degreeLabel.textContent = 'Diplôme obtenu';

                const degreeValue = document.createElement('span');
                degreeValue.classList.add('cdc-dataviz-card-details-card-about-item-label');
                degreeValue.style.cssText = 'margin-top: 0.15rem; font-size: 0.75rem; font-weight: 600;'
                degreeValue.textContent = item.degree;

                // Append the elements to the header section
                header.appendChild(card);
                card.appendChild(cardDetails);
                cardDetails.appendChild(nameElement);
                cardDetails.appendChild(occupationElement);
                cardDetails.appendChild(cardAbout);
                cardAbout.appendChild(facultyItem);
                facultyItem.appendChild(facultyLabel);
                facultyItem.appendChild(facultyValue);
                cardAbout.appendChild(degreeItem);
                degreeItem.appendChild(degreeLabel);
                degreeItem.appendChild(degreeValue);

                // Create the body section
                const bodySection = document.createElement('div');
                bodySection.classList.add('cdc-dataviz-card-component-modal-body', 'cdc-dataviz-modal-component-center');
                bodySection.style.cssText = 'width: 100%; height: 60vh; margin: 10px 0; display: flex; justify-content: center; align-items: center;'

                if (item.youtube_link) {
                    const youtubeContainer = document.createElement('div');
                    youtubeContainer.classList.add('cdc-dataviz-modal-component-youtube-container');
                    youtubeContainer.style.cssText = 'width: 100%; height: 40vh; @media screen and (max-width: 700px) {width: 100%; height: 45vh;}\n' +
                        '                            @media screen and (max-width: 1024px) and (max-height: 600px) {height: 45vh;}'
                    //
                    const iframeContainer = document.createElement('div');
                    iframeContainer.classList.add('cdc-dataviz-modal-component-youtube-container-iframe-container');
                    iframeContainer.style.cssText = 'width: 100%; height: 100%;';

                    let iframeElement = document.createElement('iframe');
                    const videoId = getVideoID(item.url);

                    // Set the attributes
                    iframeElement.id = 'id-' + videoId;
                    iframeElement.className = 'youtube-iframe';
                    iframeElement.width = '100%';
                    iframeElement.height = '100%';
                    iframeElement.style.border = '0px';
                    iframeElement.allowFullscreen = true;

                    const baseUrl = 'https://www.youtube.com/embed/';
                    const queryParams = new URLSearchParams(playerVars);
                    iframeElement.src = `${baseUrl}${videoId}?${queryParams.toString()}`;

                    iframeContainer.appendChild(iframeElement);
                    youtubeContainer.appendChild(iframeContainer);

                    bodySection.appendChild(youtubeContainer);
                } else {
                    const podcastContainer = document.createElement('div');
                    podcastContainer.classList.add('cdc-dataviz-modal-component-podcast-container');
                    podcastContainer.style.cssText = 'display: flex; flex-direction: column; width: 100%; @media screen and (min-width: 981px) and (max-width: 1600px) {\n' +
                        '                            display: flex; flex-direction: row-reverse; -webkit-flex-direction: row-reverse; -ms-flex-direction: row-reverse;\n' +
                        '                            width: 100%; height: auto;} @media screen and (min-width: 350px) and (max-width: 912px) {display: flex;\n' +
                        '                            flex-direction: column; -webkit-flex-direction: column; -ms-flex-direction: column; width: 100%; height: auto;}\n' +
                        '                            @media screen and (max-width: 1024px) and (max-height: 600px) { display: flex; flex-direction: row-reverse;\n' +
                        '                            -webkit-flex-direction: row-reverse; -ms-flex-direction: row-reverse; width: 100%; height: auto;}'

                    const podcastImgContainer = document.createElement('div');
                    podcastImgContainer.classList.add('cdc-dataviz-modal-component-podcast-img-container', 'cdc-dataviz-modal-component-center');
                    podcastImgContainer.style.cssText = 'padding-bottom: 5px; padding-left: 10px; display: flex; justify-content: center; align-items: center;'

                    const podcastLink = document.createElement('a');
                    podcastLink.href = item.url;
                    podcastLink.target = '_blank';
                    podcastLink.classList.add('cdc-dataviz-modal-component-center');
                    podcastLink.style.cssText = 'display: flex; justify-content: center; align-items: center;'

                    const podcastImg = document.createElement('img');
                    podcastImg.alt = 'Podcast';
                    podcastImg.src = 'https://vie-de-campus.unige.ch/application/files/7217/0239/3010/VOCATIONS_logo_small.jpg';
                    podcastImg.classList.add('cdc-dataviz-modal-component-podcast-img-container-img');
                    podcastImg.style.cssText = '--s: 15px; --b: 2px; --w: 12vw; --c: #7B3B3B; font-family: thesansosfplain, Helvetica, Arial, sans-serif;\n' +
                        '                                    width: var(--w); height: auto; aspect-ratio: 1; object-fit: cover; padding: calc(1*var(--s));\n' +
                        '                                    --_g: var(--c) var(--b),#0000 0 calc(100% - var(--b)),var(--c) 0; background:\n' +
                        '                                    linear-gradient(      var(--_g)) 50%/100% var(--_i,100%) no-repeat, linear-gradient(90deg,var(--_g)) 50%/var(--_i,100%) 100% no-repeat;\n' +
                        '                                    outline: calc(var(--w)/2) solid #0009; outline-offset: calc(var(--w)/-2 - 2*var(--s)); transition: .4s;\n' +
                        '                                    cursor: pointer; @media screen and (min-width: 350px) and (max-width: 912px) { --w: 30vw; }\n' +
                        '                                    @media screen and (max-width: 1024px) and (max-height: 600px) {--w: 16vw;}\n' +
                        '                                    @media screen and (max-width: 280px) and (max-height: 653px) {--w: 40vw;}'

                    const podcastPlayer = document.createElement('div');
                    podcastPlayer.classList.add('cdc-dataviz-modal-component-podcast-buzzsprout-players');
                    podcastPlayer.style.cssText = 'width: 100%; height: auto; overflow: auto; @media screen and (min-width: 350px) and (max-width: 912px) {\n' +
                        '                              height: 200px; overflow: auto;} @media screen and (max-width: 375px) and (max-height: 667px) {\n' +
                        '                              height: 120px; overflow: auto;} @media screen and (max-width: 540px) and (max-height: 720px) {\n' +
                        '                              height: 110px; overflow: auto;}'

                    const podcastPlayerContainer = document.createElement('div');
                    podcastPlayerContainer.id = item.url_embed.id;

                    podcastLink.appendChild(podcastImg);
                    podcastImgContainer.appendChild(podcastLink);
                    podcastContainer.appendChild(podcastImgContainer);
                    podcastContainer.appendChild(podcastPlayer);
                    podcastPlayer.appendChild(podcastPlayerContainer);
                    bodySection.appendChild(podcastContainer);
                }

                // Create the close button
                const closeButton = document.createElement('button');
                closeButton.classList.add('btn', 'close-button');
                closeButton.style.cssText = 'color: white; background-color: #CF0063;border-color: #CF0063;'
                closeButton.textContent = 'Fermer';
                closeButton.addEventListener('click', () => {
                    const modalWrapper = document.getElementById('id-cdc-dataviz-modal-wrapper');
                    open.value = !open.value;
                    modalWrapper.style.display = open.value ? 'flex' : 'none';
                });

                // Append the elements to the modal content
                modalContent.appendChild(header);
                modalContent.appendChild(bodySection);
                modalContent.appendChild(closeButton);

                // Append the modal content to the modal wrapper
                modalWrapper.appendChild(modalContent);

                // Append the modal wrapper to the container
                modalContainer.appendChild(modalWrapper);
            });

            // Add event listener for the Esc key
            document.addEventListener('keydown', handleEscapeEvent);
        }

        /**
         * Fonction permettant de créer un diagramme de Sankey
         * Copyright 2021 Observable, Inc.
         * Released under the ISC license.
         * https://observablehq.com/@d3/sankey/2
         * @param {Object} chartData   - Les données nécessaires pour la création du diagramme (c.-à-d. les nœuds et les liens)
         * @param {String} leftTitle   - Le titre de gauche du diagramme
         * @param {String} rightTitle  - Le titre à droite du diagramme
         * @param {Number} width       - La longueur du diagramme
         * @param {Number} height      - La hauteur du diagramme
         * @property {Object} node     - Objet correspondant à un nœud lors d'un événement (clic, etc.)
         * @property {string} node.name - Le nom du nœud (correspond au titre du débouché, ou au nom de la fac/nom du diplôme)
         * @property {string} node.full_name - Le nom complet du nœud (correspond au nom complet de la fac)
         * @property {string} node.tooltip   - Bulle d'information des débouchés
         * @property {string} node.category  - La catégorie du nœud (débouché, fac, diplôme ou débouchés-larges)
         * @property {Array}  node.data - Données contenant les informations qualitatives à afficher dans le popup
         */
        function sankeyChart(chartData, leftTitle, rightTitle, width, height) {

            // Removes all SVG containers
            // Supprime tous les conteneurs SVG
            d3.selectAll("svg > *").remove();

            const svg = d3.select("#sankey-chart")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("preserveAspectRatio", "xMidYMid meet");

            if (checkboxForResponsiveness) {
                d3.select("#sankey-chart").attr("style", "max-width: 100%; height: auto;");
            }
            else {
                d3.select("#sankey-chart").attr("style", "height: auto;");
            }

            // Constructs and configures a Sankey generator
            // Construit et configure un générateur Sankey
            const sankey = d3.sankey()
                .nodeId(d => d.name)
                .nodeAlign(d3.sankeyJustify) // d3.sankeyLeft, etc.
                .nodeWidth(NODE_WIDTH)
                .nodePadding(NODE_PADDING)
                .extent([[margin.left, margin.top], [width, height - margin.top]]);

            // Applies it to the data. We make a copy of the nodes and links objects to avoid mutating the original
            // Application aux données. Une copie des nœuds et liens est effectuée pour éviter de modifier l'original.
            const {nodes, links} = sankey({
                nodes: chartData.nodes.map(d => Object.assign({}, d)),
                links: chartData.links.map(d => Object.assign({}, d))
            });

            // Defines a color scale
            // Définit une échelle de couleurs
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            const CUSTOM_PADDING = sankey.nodeWidth() * 6;

            let div = d3.select("#tooltip");

            // Creates the rects that represent the nodes
            // Crée les rectangles qui représentent les nœuds
            svg.append("g")
                .attr("stroke", "transparent")
                .selectAll()
                .data(nodes)
                .join("rect")
                .attr("x", function (d) {
                    return d.x0 < width / 2 ? d.x1 + sankey.nodeWidth() : d.x0 - CUSTOM_PADDING;
                })
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", sankey.nodeWidth())
                .attr("fill", d => d.color)
                .attr("id", function(d, i) {
                    d.id = i;
                    return "rect-" + i;
                })
                .on("mouseover", function(ev, node) {
                    const nodeCategory = node.category;

                    highlightNodeLinks(ev, node, this);
                    if (nodeCategory === "facs" || nodeCategory === "débouchés-larges") {
                        d3.select(this).style("cursor", "zoom-in");
                    }
                    else {
                        d3.select(this).style("cursor", "zoom-out");
                    }

                    const tooltip = getNodeTooltipText(node);
                    div.transition()
                        .duration(800)
                        .style("opacity", 0.9);

                    div.html(tooltip)
                        .style("left", (ev.pageX + 20) + "px")
                        .style("top", (ev.pageY + 5) + "px");
                })
                .on("mouseout", function(ev, node) {
                    highlightNodeLinks(ev, node, this);
                    d3.select(this).style("cursor", "default");

                    div.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", function (ev, node) {
                    const nodeCategory = node.category;
                    if (nodeCategory === "facs" || nodeCategory === "débouchés-larges") {
                        return zoomIn(ev, node);
                    }
                    else {
                        return zoomOut(ev);
                    }
                });

            // Creates the paths that represent the links
            // Crée les chemins qui représentent les liens
            const link = svg.append("g")
                .attr("fill", "none")
                .attr("stroke-opacity", 0.5)
                .selectAll()
                .data(links)
                .join("g")
                .style("mix-blend-mode", "multiply")
                .attr("transform", `translate(${sankey.nodeWidth()},0)`)
                .on("mouseover", function(ev, node) {
                    const tooltip = getLinkTooltipText(node);
                    div.transition()
                        .duration(800)
                        .style("opacity", 0.9);

                    div.html(tooltip)
                        .style("left", (ev.pageX + 20) + "px")
                        .style("top", (ev.pageY + 5) + "px");

                    d3.select(this)
                        .style("stroke-opacity", "0.7")
                })
                .on("mouseout", function() {
                    div.transition()
                        .duration(500)
                        .style("opacity", 0);

                    d3.select(this)
                        .style("stroke-opacity", "0.5")
                })
                .style("stroke-width", function (d) {
                    return Math.max(1, d.dy);
                });

            const gradientId = generateRandomString(10);

            // Creates a gradient de couleur
            // Crée un dégradé de couleur
            const gradient = link.append("linearGradient")
                .attr("id", gradientId)
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", d => d.source.x1)
                .attr("x2", d => d.target.x0);
            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", d => color(d.source.name));
            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", d => color(d.target.name));

            function horizontalSource(d) {
                return [d.source.x1 + sankey.nodeWidth(), d.y0];
            }

            function horizontalTarget(d) {
                return [d.target.x0 - (sankey.nodeWidth() * 7), d.y1];
            }

            link.append("path")
                .attr("d", d3.sankeyLinkHorizontal().source(horizontalSource).target(horizontalTarget))
                .attr("id", function(d, i) {
                    d.id = i;
                    return "link-" + i;
                })
                .attr("stroke", function (d) {
                    return d.source.color;
                })
                .attr("stroke-width", d => Math.max(1, d.width));

            // Adds labels on the nodes
            // Ajoute des libellés aux nœuds
            svg.append("g")
                .selectAll()
                .data(nodes)
                .join("text")
                .style("font-family", "thesanscdlight, Helvetica, Arial, sans-serif")
                .style("font-size", function () {
                    return DEFAULT_FONT_SIZE;
                })
                .attr("x", function (d) {
                    return d.x0 < width / 2 ? d.x1 + sankey.nodeWidth() - 6 : d.x1 - CUSTOM_PADDING + 6;
                })
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "end" : "start")
                .attr("id", function(d, i) {
                    d.id = i;
                    return "text-" + i;
                })
                .on("mouseover", function(ev, node) {
                    const elementId = getElementId(this);

                    const matchingRect = d3.select("#rect-" + elementId).node();
                    highlightNodeLinks(ev, node, matchingRect);
                })
                .on("mouseout", function(ev, node) {
                    const elementId = getElementId(this);

                    const matchingRect = d3.select("#rect-" + elementId).node();
                    highlightNodeLinks(ev, node, matchingRect);
                })
                .text(function (d) {
                    return d.name;
                });

            // Adds a title to the top left
            // Ajoute un titre en haut à gauche
            svg.append("text")
                .attr("id", "left-title")
                .classed("chart-titles", true)
                .attr("x", sankey.nodeWidth() * 5)
                .attr("y", 25)
                .attr("text-anchor", "start")
                .attr("alignment-baseline", "hanging")
                .style("font-size", "2em")
                .style("font-weight", "bold")
                .style("font-family", "thesansosfextrabold, Helvetica, Arial, sans-serif")
                .text(leftTitle);

            // Adds a title to the top right
            // Ajoute un titre en haut à droite
            svg.append("text")
                .attr("id", "right-title")
                .classed("chart-titles", true)
                .attr("x", width - sankey.nodeWidth() * 3)
                .attr("y", 25)
                .attr("text-anchor", "end")
                .attr("alignment-baseline", "hanging")
                .style("font-size", "2em")
                .style("font-weight", "bold")
                .style("font-family", "thesansosfextrabold, Helvetica, Arial, sans-serif")
                .text(rightTitle);

            // Adds links to multimedia content where possible (only in diagrams 2, 3 and 4)
            // Ajoute les liens vers les contenus multimédia si possible (uniquement dans les diagrammes 2, 3 et 4)
            const validStates = [CHART_STATES.TWO, CHART_STATES.THREE, CHART_STATES.FOUR];
            if (validStates.includes(currentChartState)) {
                const bubbleWidth = 70;
                const bubbleHeight = 40;
                svg.append("svg")
                    .selectAll()
                    .data(function () {
                        // Filter data to keep only prospects with related qualitative data
                        // Filtre les données pour garder uniquement les débouchés qui ont des données qualitatives liées
                        return nodes.filter(node => {
                            return (node.category === "débouché" || node.category === "débouchés-larges") && node.data.length > 0;
                        });
                    })
                    .join("svg")
                    .attr("class", "bubble-icons")
                    .attr("viewBox", [0, 0, 512, 512])
                    .attr("x", function (d) {
                        const leftPadding = sankey.nodeWidth() * 1.75;
                        const rightPadding = sankey.nodeWidth() * 7;
                        return d.x0 < width / 2 ? d.x1 + leftPadding : d.x0 - rightPadding - 30;
                    })
                    .attr("y", function (d) {
                        const y = (d.y1 + d.y0) / 2;
                        return y - (bubbleHeight / 2);
                    })
                    .attr('width', bubbleWidth)
                    .attr('height', bubbleHeight)
                    .attr("text-anchor", d => d.x0 < width / 2 ? "end" : "start")
                    .append("path")
                    .attr("d", function () {
                        return commentDotsSolidIconSvgPath;
                    })
                    .attr("stroke-width", "40")
                    .attr("stroke", "black")
                    .attr("fill", "white")
                    .on("mouseover", function() {
                        d3.select(this).style("cursor", "pointer")
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("cursor", "default")
                    })
                    .on("click", function (event, node) {
                        const modalWrapper = document.getElementById('id-cdc-dataviz-modal-wrapper');
                        open.value = !open.value;
                        modalWrapper.style.display = open.value ? 'flex' : 'none';
                        data = node.data;
                        updateModalInfo();
                    });
            }

            return svg.node();
        }

        /**
         * Permet de mettre à jour le diagramme de Sankey
         * @param {Object} chartData              - Les données nécessaires pour la génération du diagramme de Sankey
         * @param {String} leftTitle    - Le titre de gauche du diagramme
         * @param {String} rightTitle   - Le titre à droite du diagramme
         * @param {String|Number} selectedYear    - L'année sélectionnée par l'utilisateur
         * @param {String} newState               - Le nouvel état du diagramme, après la transition qui sera effectuée
         * @param {Number} width                  - La longueur du diagramme
         * @param {Number} height                 - La hauteur du diagramme
         * @returns {Promise<void>}
         */
        async function updateChart(chartData, newState, selectedYear, leftTitle, rightTitle, width, height) {
            currentChartState = newState;
            sankeyChart(await chartData, leftTitle, rightTitle, width, height);
        }

        /**
         * Permet de faire un deep down dans les données
         * @param event   - L'événement déclenché par le clic sur le nœud
         * @param node    - Le nœud sur lequel l'utilisateur a cliqué
         */
        function zoomIn(event, node) {
            const nodeName = node.name;
            const nodeCategory = node.category;

            /*
            When the user clicks on a node, we check its category.
            Category "facs", the diagram is in 2 possible states : facs → broad prospects (1) or facs → specific prospects (3).
            Category "débouché large", the diagram is in 2 possible states : facs → broad prospects (1) or diplomas → specific prospects (2).
            "diplôme"" and "débouché" categories : No modification is possible
             */
            /*
            Lorsque l'utilisateur clique sur un nœud, on vérifie sa catégorie
            Catégorie "facs", le diagramme est dans 2 états possibles : facs → débouchés larges (1) ou facs → débouchés spécifiques (3).
            Catégorie "débouché large", le diagramme est dans 2 états possibles : facs → débouchés larges (1) ou diplômes → débouchés spécifiques (2).
            Catégories "diplôme" et "débouché" : Aucune modification n'est possible
             */
            width.value = computedWidth;
            height.value = computedHeight;
            switch (nodeCategory) {
                case "facs":
                    switch (currentChartState) {
                        case CHART_STATES.ONE:
                            lastFac = nodeName;

                            chartData = getData(lastFac, "", selectedYear.value);

                            updateChart(chartData, CHART_STATES.TWO, selectedYear.value, lastFac, DEFAULT_RIGHT_TITLE, width.value, height.value);

                            leftDeepDown.value = true;
                            break;
                        case CHART_STATES.THREE:
                            lastFac = nodeName;

                            chartData = getData(lastFac, lastProspect, selectedYear.value);

                            updateChart(chartData, CHART_STATES.FOUR, selectedYear.value, lastFac, lastProspect, width.value, height.value);

                            leftDeepDown.value = true;
                            break;
                        default:
                            break;
                    }
                    break;
                case "diplôme":
                    break;
                case "débouché":
                    break;
                case "débouchés-larges":
                    switch (currentChartState) {
                        case CHART_STATES.ONE:
                            lastProspect = nodeName;

                            chartData = getData("", lastProspect, selectedYear.value);

                            updateChart(chartData, CHART_STATES.THREE, selectedYear.value, DEFAULT_LEFT_TITLE, lastProspect, width.value, height.value);

                            rightDeepDown.value = true;
                            break;
                        case CHART_STATES.TWO:
                            lastProspect = nodeName;

                            chartData = getData(lastFac, lastProspect, selectedYear.value);

                            updateChart(chartData, CHART_STATES.FOUR, selectedYear.value, lastFac, lastProspect, width.value, height.value);

                            rightDeepDown.value = true;
                            break;
                        default:
                            break;
                    }
            }
        }

        /**
         * Permet de "remonter" dans les données du diagramme
         * @param event     - L'événement déclenché par le clic sur l'icône
         */
        function zoomOut(event) {
            /*
            Depending on the zoom icon used (left or right), or the click on a node after a deep down,
            a transition is made to the previous diagram.
            In the case of left zoom-out, the diagram is in 2 possible states : Diplomas → broad prospects (2) or Diplomas → specific prospects (4).
            In the right zoom-out case, the diagram is in 2 possible states : facs → specific prospects (3) or diplomas → specific prospects (4).
             */
            /*
            En fonction de l'icône de zoom utilisée (gauche ou droite), ou du clic sur un nœud après un deep down,
            on effectue une transition vers le diagramme précédent.
            Dans le cas du zoom-out gauche, le diagramme est dans 2 états possibles : diplômes → débouchés larges (2) ou diplômes → débouchés spécifiques (4).
            Dans le cas du zoom-out droit, le diagramme est dans 2 états possibles : facs → débouchés spécifiques (3) ou diplômes → débouchés spécifiques (4).
             */

            // Html identifiers for the zoom icons
            // Identifiants html des icônes de zoom
            const zoomIds = ["left-zoom-out", "right-zoom-out"]
            const targetId = event.target.id;

            let nodeCategory = "";
            if (targetId.includes("rect")) {
                nodeCategory = event.target.__data__.category;
            }

            let validTargetId;
            validTargetId = !!(zoomIds.includes(targetId) || nodeCategory);

            switch (validTargetId) {
                case currentChartState === CHART_STATES.TWO:
                    chartData = getData("", "", selectedYear.value);
                    updateChart(chartData, CHART_STATES.ONE, selectedYear.value, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, height.value);

                    leftDeepDown.value = false;
                    break;
                case (targetId === "left-zoom-out" || nodeCategory === "diplôme") && currentChartState === CHART_STATES.FOUR:
                    chartData = getData("", lastProspect, selectedYear.value);
                    updateChart(chartData, CHART_STATES.THREE, selectedYear.value, DEFAULT_LEFT_TITLE, lastProspect, width.value, height.value);

                    leftDeepDown.value = false;
                    break;
                case currentChartState === CHART_STATES.THREE:
                    chartData = getData("", "", selectedYear.value);
                    updateChart(chartData, CHART_STATES.ONE, selectedYear.value, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, height.value);

                    rightDeepDown.value = false;
                    break;
                case (targetId === "right-zoom-out" || nodeCategory === "débouché") && currentChartState === CHART_STATES.FOUR:
                    chartData = getData(lastFac, "", selectedYear.value);
                    updateChart(chartData, CHART_STATES.TWO, selectedYear.value, lastFac, DEFAULT_RIGHT_TITLE, width.value, height.value);

                    rightDeepDown.value = false;
                    break;
                default:
                    break;
            }
        }

        /**
         * Permet d'activer/désactiver la surbrillance pour les nœuds et les liens sur lesquels l'utilisateur passe la souris
         * @param ev        - L'événement enregistré (par exemple 'MouseEvent')
         * @param node      - Le nœud du diagramme
         * @param element   - L'élément HTML à modifier
         */
        function highlightNodeLinks(ev, node, element) {
            let remainingNodes = [],
                nextNodes = [];

            if (d3.select(element).attr("data-clicked") === "1") {
                d3.select(element).attr("data-clicked", "0");
                d3.selectAll("path").transition(TRANSITION_DURATION).style("opacity", 1); // back to default
                d3.selectAll("rect").transition(TRANSITION_DURATION).style("opacity", 1);
                d3.selectAll("text")
                    .filter(function () {
                        return !this.classList.contains("chart-titles");
                    })
                    .transition(TRANSITION_DURATION)
                    .style("opacity", 1)
                    .style("font-size", DEFAULT_FONT_SIZE)
                    .style("font-weight", "normal");
                return;
            } else {
                d3.select(element).attr("data-clicked", "1");
                d3.selectAll("path").transition(TRANSITION_DURATION).style("opacity", 0.1);
                d3.selectAll("rect").transition(TRANSITION_DURATION).style("opacity", 0.1);
                d3.selectAll("text")
                    .filter(function () {
                        return !this.classList.contains("chart-titles");
                    })
                    .transition(TRANSITION_DURATION)
                    .style("opacity", 0.1);

                d3.select(element).transition(TRANSITION_DURATION).style("opacity", 1);

                const elementId = getElementId(element);
                d3.select("#text-" + elementId)
                    .transition(TRANSITION_DURATION)
                    .style("opacity", 1)
                    .style("font-size", HIGHLIGHT_FONT_SIZE)
                    .style("font-weight", "bold");
            }

            const traverse = [
                {
                    linkType: "sourceLinks",
                    nodeType: "target"
                },
                {
                    linkType: "targetLinks",
                    nodeType: "source"
                }
            ];

            traverse.forEach(function(step) {
                node[step.linkType].forEach(function(link) {
                    remainingNodes.push(link[step.nodeType]);
                    d3.select("#link-" + link.id).transition(TRANSITION_DURATION).style("opacity", 1);
                });

                while (remainingNodes.length) {
                    nextNodes = [];
                    remainingNodes.forEach(function(node) {
                        node[step.linkType].forEach(function(link) {
                            nextNodes.push(link[step.nodeType]);
                            d3.select("#link-" + link.id).transition(TRANSITION_DURATION).style("opacity", 1);
                        });
                        d3.select("#rect-" + node.index).transition(TRANSITION_DURATION).style("opacity", 1);
                        d3.select("#text-" + node.index).transition(TRANSITION_DURATION).style("opacity", 1);
                    });
                    remainingNodes = nextNodes;
                }
            });
        }

        /**
         * Permet de gérer la mise à jour des données qualitatives
         */
        function watchData() {
            let previousData = [...data];

            function handleDataChange() {
                const currentData = [...data];

                // Check if the data has changed
                if (JSON.stringify(previousData) !== JSON.stringify(currentData)) {
                    previousData = currentData;

                    // Perform the necessary actions when the data changes
                    nextTick(() => {
                        removeAllScriptTags();

                        for (const element of currentData) {
                            const isYoutubeLink = element.youtube_link;
                            if (isYoutubeLink) {
                                if (open) {
                                    continue;
                                }
                                pauseAllYouTubeVideos();
                            }

                            const urlEmbedInfo = element.url_embed;
                            const scriptSrc = urlEmbedInfo.src;
                            addJsScript(scriptSrc);
                        }
                    });
                }
            }

            // Watch for changes in the 'data' array
            setInterval(handleDataChange, 100);
        }

        /**
         * Fonction permettant d'enlever toutes les balises <scripts>.
         */
        function removeAllScriptTags() {
            let r = document.getElementsByTagName('script');

            for (let i = (r.length-1); i >= 0; i--) {
                if(r[i].getAttribute('id') !== 'a'){
                    r[i].parentNode.removeChild(r[i]);
                }

            }
        }

        /**
         * Fonction permettant d'ajouter une balise <script> (pour les podcasts buzzsprout).
         * @param src
         */
        function addJsScript(src) {
            let script = document.createElement("script");
            script.setAttribute("src", src);
            script.setAttribute("type", "text/javascript");
            script.setAttribute("charset", "utf-8");
            document.body.appendChild(script);
        }

        /**
         * Fonction permettant de mettre en pause toutes les vidéos (lorsque l'utilisateur quitte le popup).
         */
        function pauseAllYouTubeVideos() {
            let iframes = document.querySelectorAll('iframe');
            Array.prototype.forEach.call(iframes, iframe => {
                iframe.contentWindow.postMessage(JSON.stringify({ event: 'command',
                    func: 'pauseVideo' }), '*');
            });
        }

        /**
         * Fonction permettant d'afficher le nom du répondant si disponible
         * @param item      - Les informations du répondant
         * @return {string} - Une chaîne de caractère constituée du prénom et du nom. "Saitama" est le nom utilisé par défaut.
         */
        function displayName(item) {
            if (item.first_name === "-" && item.last_name === "-")
                return "";

            return `${item.first_name} ${item.last_name}`
        }

        /**
         * Fonction permettant de convertir le diagramme sous le format JPEG
         */
        function saveToJpeg() {
            htmlToImage.toJpeg(document.getElementById(sankeyChartId),
                {
                    type: jpegFormatType,
                    backgroundColor: backgroundColor
                })
                .then(function (dataUrl) {
                    const link = document.createElement('a');
                    link.download = 'chart.jpeg';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                })
        }

        /**
         * Fonction permettant de convertir le diagramme sous le format PNG
         */
        function saveToPng() {
            htmlToImage.toPng(document.getElementById(sankeyChartId),
                {
                    type: pngFormatType,
                    backgroundColor: backgroundColor
                })
                .then(function (dataUrl) {
                    const link = document.createElement('a');
                    link.download = 'chart.png';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                })
                .catch(function (error) {
                    console.error("Erreur lors de l'export de l'image: ", error);
                });
        }

        /**
         * Fonction permettant de convertir le diagramme sous le format SVG
         */
        function saveToSvg() {
            // On enlève le dernier nœud (qui correspond à celui contenant les images des bulles)
            const originalSvg = document.getElementById(sankeyChartId);
            const lastChild = originalSvg.removeChild(originalSvg.lastChild);

            htmlToImage.toSvg(originalSvg,
                {
                    type: svgFormatType,
                })
                .then(function (dataUrl) {
                    const link = document.createElement('a');
                    link.download = 'chart.svg';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    originalSvg.appendChild(lastChild); // On remet le nœud supprimé après avoir téléchargé le fichier
                })
                .catch(function (error) {
                    console.error("Erreur lors de l'export de l'image: ", error);
                });
        }

        /**
         * Fonction permettant de gérer la touche "Esc"
         * @param event     - L'événement déclenché par l'utilisateur
         */
        function handleEscapeEvent (event) {
            if (event.key === 'Escape') {
                const modalWrapper = document.getElementById('id-cdc-dataviz-modal-wrapper');
                open.value = !open.value;
                modalWrapper.style.display = open.value ? 'flex' : 'none';

                // On retire le gestionnaire d'événements
                document.removeEventListener('keydown', handleEscapeEvent);
            }
        }

        /**
         * Fonction permettant de réinitialiser les dimensions du diagramme
         */
        function resetChartDimensions() {
            width.value = computedWidth;
            height.value = computedHeight;
            switch (currentChartState) {
                case CHART_STATES.ONE:
                    chartData = getData("", "", selectedYear.value);
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, height.value);
                    break;
                case CHART_STATES.TWO:
                    chartData = getData(lastFac, "", selectedYear.value);
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, DEFAULT_RIGHT_TITLE, width.value, height.value);
                    break;
                case CHART_STATES.THREE:
                    chartData = getData("", lastProspect, selectedYear.value);
                    updateChart(chartData, currentChartState, selectedYear.value, DEFAULT_LEFT_TITLE, lastProspect, width.value, height.value);
                    break;
                case CHART_STATES.FOUR:
                    chartData = getData(lastFac, lastProspect, selectedYear.value);
                    updateChart(chartData, currentChartState, selectedYear.value, lastFac, lastProspect, width.value, height.value);
                    break;
                default:
                    break;
            }
            document.getElementById('widthSlider').value = width.value;
            document.getElementById('heightSlider').value = height.value;

            dimensionsUpdated.value = false;
            const resetDimensionsButton = document.getElementById('id-btn-reset-chart-dimensions');
            resetDimensionsButton.style.display = dimensionsUpdated.value ? '' : 'none';
        }

        const app = Vue.createApp({
            setup() {
                onMounted(async () => {
                    watchData();
                    currentChartState = CHART_STATES.ONE;
                    chartData = await getData("", "", selectedYear.value);
                    sankeyChart(chartData, DEFAULT_LEFT_TITLE, DEFAULT_RIGHT_TITLE, width.value, height.value);
                    handleResponsiveness();
                });
            }
        });

      app.mount('#app')
	</script>

</body>
</html>
